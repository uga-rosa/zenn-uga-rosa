---
title: "Server Side Kotlin with Micronaut"
emoji: "ğŸ”¬"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Kotlin", "Micronaut"]
published: true
---

# ã¯ã˜ã‚ã«

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§Kotlinã‚’æ¡ç”¨ã™ã‚‹å ´åˆã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®é¸å®šã«è¿·ã„ã¾ã™ã‚ˆã­ã€‚micronaut (+ jdbi3) ãŒæœ€ã‚‚ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã•ãã†ã ã¨ã„ã†çµè«–ã«ã„ãŸã£ãŸã®ã§ã€ãã®æ§‹æˆã‚’å®Ÿè£…ã‚’æ··ã˜ãˆãªãŒã‚‰ç´¹ä»‹ã—ã¾ã™ã€‚

ä½¿ç”¨ã—ãŸrepositoryã¯ã“ã¡ã‚‰ã€‚

https://github.com/uga-rosa/micronaut-demo/tree/develop

# é¸å®šç†ç”±

Kotlinå‘ã‘ã®Webãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¨ã—ã¦æœ‰åãªã‚‚ã®ã¨ã—ã¦ã€Springã¨KtorãŒã‚ã‚Šã¾ã™ãŒ

- Springã¯é…ã„ã€‚
- ktorã®ã‚ˆã†ãªè–„ã„ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã¯DIãªã©é¢å€’ãªéƒ¨åˆ†ãŒå¤šã„ã€‚

ãã®ãŸã‚ã€é«˜æ€§èƒ½ã§æˆç†Ÿã—ãŸãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ï¼ˆ=Javaè£½ï¼‰ã‹ã¤ã€å…¬å¼ã«Kotlinã‚µãƒãƒ¼ãƒˆãŒã‚ã‚‹ã‚‚ã®ã‚’æ±‚ã‚ãŸçµæœã€micronautã«è¾¿ã‚Šç€ãã¾ã—ãŸã€‚

ã¾ãŸã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«micronaut-dataã¯ç´ ã®SQLã‚’æ›¸ãã®ã«ã¯å‘ã„ã¦ã„ã¾ã›ã‚“ã€‚
å˜ç´”ãªCrudRepositoryãªã©ã¯interfaceã ã‘ã§ç°¡å˜ã«ç”Ÿæˆã§ãã‚‹ã®ã§ä¾¿åˆ©ã§ã™ãŒã€Springã®JdbcClientã®ã‚ˆã†ã«è¤‡é›‘ãªã‚¯ã‚¨ãƒªã‚’ç›´æ¥è¨˜è¿°ã—ãŸã„å ´åˆã¯jdbi3ã‚’ä½µç”¨ã™ã‚‹ã®ãŒã„ã„ã§ã—ã‚‡ã†ã€‚
ä»Šå›ã¯jdbi3ã¯ä½¿ã‚ãšã€micronaut-data-jdbcã®CrudRepositoryã ã‘ã§å®Ÿè£…ã—ã¾ã™ã€‚

# å°å…¥

ã§ã¯å®Ÿè£…ä¾‹ã‚’æ·»ãˆã¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ç°¡å˜ã®ãŸã‚ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ã¯å˜ç´”ãªCRUDã§æ¸ˆã‚€TODOã‚¢ãƒ—ãƒªã«ã—ã¾ã™ãŒã€èªè¨¼ãªã©ã¯ãã¡ã‚“ã¨ä½œã‚Šã¾ã™ã€‚CAãƒ™ãƒ¼ã‚¹ã§è¨­è¨ˆã—ã¾ã™ãŒã€DIç”¨ã®ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’importã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ç¾æ™‚ç‚¹ã®æœ€æ–°ç‰ˆã§ã‚ã‚‹ã€Micronaut 4.8.0ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚

ç§ãŒæ…£ã‚Œã¦ã„ã‚‹ã®ã§ã€è¨€èªã¯Kotlinã€ãƒ“ãƒ«ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ã¯Gradleã‚’æ¡ç”¨ã—ã¾ã™ã€‚IntelliJ IDEA Ultimateã‚’æŒã£ã¦ã„ã‚‹ãªã‚‰IDEAä¸Šã§ã‚‚ä½œæˆã§ãã¾ã™ãŒã€ä»Šå›ã¯micronaut cliã‚’ä½¿ç”¨ã—ã¾ã—ã‚‡ã†ã€‚sdkmanã§å…¥ã‚Œã¾ã™ã€‚

https://docs.micronaut.io/4.8.0/guide/#buildCLI

```bash
# ã¾ã sdkmanã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ã„ãªã„å ´åˆ
# curl -s "https://get.sdkman.io" | bash 
# source "~/.sdkman/bin/sdkman-init.sh"
sdk update && sdk install micronaut
```

ãƒ•ãƒ©ã‚°ã§æœ‰åŠ¹ã«ã™ã‚‹æ©Ÿèƒ½ã‚’é¸æŠã—ã¾ã™ã€‚jdbcã‚’hikariCPã§ä½¿ã†ã“ã¨ã«ã—ã¾ã—ãŸã€‚databaseã«ã¯postgersã‚’é¸ã³ã¾ã—ãŸã€‚

```bash
mn create-app micronaut-demo --lang kotlin --build gradle --test kotest --jdk 21 --features data-jdbc,jdbc-hikari,postgres,flyway,security-jwt
```

ã“ã‚Œã§ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä»¥ä¸‹ã« `micronaut-demo/` ã¨ã„ã†ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸã€‚Application.ktã ã‘ã®ç©ºã£ã½ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã™ã€‚

# å®Ÿè£…ä¾‹

ã§ã¯å®Ÿè£…ã‚’é€²ã‚ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

CAã£ã½ã3å±¤ï¼ˆadapter/application/domainï¼‰ã§ã‚„ã‚Šã¾ã™ã€‚

## Domain

ã¾ãšã¯ãƒ‰ãƒ¡ã‚¤ãƒ³å®šç¾©ã‹ã‚‰ã§ã™ã€‚

TODOã®ã‚¿ã‚¹ã‚¯ã‚’è¡¨ç¾ã™ã‚‹ `Task` ã¨ãã‚Œã®æ‰€æœ‰è€… `User` ãŒã‚ã‚Œã°ã„ã„ã§ã—ã‚‡ã†ã€‚IDãŒnullableã«ãªã£ã¦ã—ã¾ã†ã®ãŒå«Œãªã®ã§ã€æ–°è¦ä½œæˆç”¨ã®ãƒ¢ãƒ‡ãƒ«ã¯åˆ†ã‘ã¾ã™ã€‚

```
domain/
  entity/
    Task.kt
    User.kt
  repository/
    TaskRepository.kt
```

```kotlin
package micronaut.demo.domain.entity

import java.time.Instant

data class Task(
    val id: Long,
    val userId: Long,
    val name: String,
    val description: String,
    val isCompleted: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
)

data class NewTask(
    val userId: Long,
    val name: String,
    val description: String,
)
```

```kotlin
package micronaut.demo.domain.entity

data class User(
    val id: Long,
    val username: String,
    val passwordHash: String,
)

data class NewUser(
    val username: String,
    val passwordHash: String,
)
```

```kotlin
package micronaut.demo.domain.repository

import micronaut.demo.domain.entity.NewTask
import micronaut.demo.domain.entity.Task

interface TaskRepository {
    fun save(task: NewTask): Task
    fun findById(id: Long): Task?
    fun findByUserId(userId: Long): List<Task>
    fun update(task: Task): Task
    fun deleteById(id: Long): Boolean
}
```

## Application (Usecase)

åŸºæœ¬æ“ä½œã®usecaseã‚’ä½œæˆã—ã¾ã™ã€‚ç°¡å˜ã®ãŸã‚ã«ä»Šå›ã¯ä¾‹å¤–ã§ã‚¨ãƒ©ãƒ¼å‡¦ç†ã—ã¾ã™ãŒã€arrow-coreã®Eitherãªã©ã‚’ä½¿ã£ã¦å‡¦ç†ã—ãŸæ–¹ãŒã„ã„ã¨æ€ã„ã¾ã™ã€‚

```
application/
  usecase/
    CreateTaskUsecase.kt
    ListTaskUsecase.kt
    UpdateTaskUsecase.kt
    DeleteTaskUsecase.kt
```

```kotlin
package micronaut.demo.application.usecase

import jakarta.inject.Singleton
import micronaut.demo.domain.entity.NewTask
import micronaut.demo.domain.entity.Task
import micronaut.demo.domain.repository.TaskRepository

interface CreateTaskUsecase {
    fun execute(userId: Long, title: String, description: String): Task
}

@Singleton
class CreateTaskUsecaseImpl(
    private val taskRepository: TaskRepository,
) : CreateTaskUsecase {
    override fun execute(userId: Long, title: String, description: String): Task {
        val newTask = NewTask(userId, title, description)
        return taskRepository.save(newTask)
    }
}
```

```kotlin
package micronaut.demo.application.usecase

import jakarta.inject.Singleton
import micronaut.demo.domain.entity.Task
import micronaut.demo.domain.repository.TaskRepository

interface ListTaskUsecase {
    fun execute(userId: Long): List<Task>
}

@Singleton
class ListTaskUsecaseImpl(
    private val taskRepository: TaskRepository,
) : ListTaskUsecase {
    override fun execute(userId: Long): List<Task> {
        return taskRepository.findByUserId(userId)
    }
}
```

```kotlin
package micronaut.demo.application.usecase

import jakarta.inject.Singleton
import micronaut.demo.domain.entity.Task
import micronaut.demo.domain.repository.TaskRepository

interface UpdateTaskUsecase {
    fun execute(
        userId: Long,
        id: Long,
        title: String?,
        description: String?,
        isCompleted: Boolean?,
    ): Task
}

@Singleton
class UpdateTaskUsecaseImpl(
    private val taskRepository: TaskRepository,
) : UpdateTaskUsecase {
    override fun execute(
        userId: Long,
        id: Long,
        title: String?,
        description: String?,
        isCompleted: Boolean?,
    ): Task {
        val task = taskRepository.findById(id)
            ?: throw IllegalArgumentException("Task with id $id not found")
        if (task.userId != userId) {
            throw IllegalArgumentException("Task with id $id does not belong to user $userId")
        }
        val updatedTask = task.copy(
            title = title ?: task.title,
            description = description ?: task.description,
            isCompleted = isCompleted ?: task.isCompleted,
        )
        return taskRepository.update(updatedTask)
    }
}

```

```kotlin
package micronaut.demo.application.usecase

import jakarta.inject.Singleton
import micronaut.demo.domain.entity.Task
import micronaut.demo.domain.repository.TaskRepository

interface UpdateTaskUsecase {
    fun execute(userId: Long, id: Long, title: String?, description: String?): Task
}

@Singleton
class UpdateTaskUsecaseImpl(
    private val taskRepository: TaskRepository,
) : UpdateTaskUsecase {
    override fun execute(userId: Long, id: Long, title: String?, description: String?): Task {
        val task = taskRepository.findById(id)
            ?: throw IllegalArgumentException("Task with id $id not found")
        if (task.userId != userId) {
            throw IllegalArgumentException("Task with id $id does not belong to user $userId")
        }
        val updatedTask = task.copy(
            title = title ?: task.title,
            description = description ?: task.description,
        )
        return taskRepository.update(updatedTask)
    }
}
```

Useré–¢é€£ã®Usecaseã¯èªè¨¼ã®ç« ã§ã¾ã¨ã‚ã¦ã‚„ã‚Šã¾ã™ã€‚

## Adapter (Controller)

Annotation baseã§æ›¸ã‘ã¾ã™ã€‚Springã£ã½ã„ã§ã™ã­ã€‚
å…ˆã«èªè¨¼å‘¨ã‚Šã‚’ä½œã‚‰ãªã„ã¨userIdãŒå–ã‚Œãªã„ã®ã§ã€ä¸€æ—¦TODOã«ã—ã¦ãŠãã¾ã™ã€‚

ã¾ãŸã€æœ¬æ¥ã¯IDã‚’ãã®ã¾ã¾å¤–éƒ¨ã«å…¬é–‹ã™ã‚‹ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯å¿…ãšæš—å·åŒ–ã—ã¦ãã ã•ã„ã€‚ä»Šå›ã¯å®Ÿè£…ã®ç°¡æ½”ã•ã‚’å„ªå…ˆã—ã¦ã„ã¾ã™ã€‚

```
adapter/
  controller/
    request/
      CreateTaskRequest.kt
      UpdateTaskRequest.kt
    response/
      TaskResponse.kt
    TaskController.kt
```

```kotlin
package micronaut.demo.adapter.controller

import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Body
import io.micronaut.http.annotation.Consumes
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Delete
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Patch
import io.micronaut.http.annotation.PathVariable
import io.micronaut.http.annotation.Post
import io.micronaut.http.annotation.Produces
import micronaut.demo.application.usecase.CreateTaskUsecase
import micronaut.demo.application.usecase.DeleteTaskUsecase
import micronaut.demo.application.usecase.ListTaskUsecase
import micronaut.demo.application.usecase.UpdateTaskUsecase
import micronaut.demo.interfaces.controller.request.CreateTaskRequest
import micronaut.demo.interfaces.controller.request.UpdateTaskRequest
import micronaut.demo.interfaces.controller.response.TaskResponse

@Controller("/tasks")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
class TaskController(
    private val createTaskUsecase: CreateTaskUsecase,
    private val listTaskUsecase: ListTaskUsecase,
    private val updateTaskUsecase: UpdateTaskUsecase,
    private val deleteTaskUsecase: DeleteTaskUsecase,
) {
    @Get
    fun listTasks(): List<TaskResponse> {
        TODO()
    }

    @Post
    fun createTask(
        @Body body: CreateTaskRequest,
    ): TaskResponse {
        TODO()
    }

    @Patch("/{id}")
    @Consumes(MediaType.APPLICATION_JSON_MERGE_PATCH)
    fun updateTask(
        @PathVariable id: Long,
        @Body body: UpdateTaskRequest,
    ): TaskResponse {
        TODO()
    }

    @Delete("/{id}")
    fun deleteTask(
        @PathVariable id: Long,
    ) {
        TODO()
    }
}
```

```kotlin
package micronaut.demo.adapter.controller.request

import io.micronaut.serde.annotation.Serdeable

@Serdeable
data class CreateTaskRequest(
    val title: String,
    val description: String,
)
```

```kotlin
package micronaut.demo.adapter.controller.request

import io.micronaut.serde.annotation.Serdeable

@Serdeable
data class UpdateTaskRequest(
    val title: String?,
    val description: String?,
    val isCompleted: Boolean?,
)
```

```kotlin
package micronaut.demo.adapter.controller.response

import io.micronaut.serde.annotation.Serdeable

@Serdeable
data class TaskResponse(
    val id: Long,
    val userId: Long,
    val title: String,
    val description: String,
    val isCompleted: Boolean,
    val createdAt: String,
    val updatedAt: String,
)

fun Task.toResponse(): TaskResponse =
    TaskResponse(
        id = id,
        userId = userId,
        title = title,
        description = description,
        isCompleted = isCompleted,
        createdAt = createdAt.toString(),
        updatedAt = updatedAt.toString(),
    )
```

## Adapter (Persistence)

ã¾ãšã¯docker-composeã§postgresã‚’èµ·å‹•ã—ã¾ã—ã‚‡ã†ã€‚

ç°¡å˜ã®ãŸã‚ã«è‰²ã€…ç›´æ›¸ãã—ã¦ã„ã¾ã™ãŒã€å®Ÿéš›ã®é–‹ç™ºã§ã¯ç’°å¢ƒå¤‰æ•°ãªã©ã§ã‚»ã‚­ãƒ¥ã‚¢ã«æ‰±ã£ã¦ãã ã•ã„ã€‚

```yaml
services:
  micronaut-demo-db:
    image: postgres:17.4
    container_name: postgres_17
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: demo
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

```bash
docker compose up -d
```

åˆæœŸåŒ–ã®SQLã‚‚æ›¸ã„ã¦ãŠãã¾ã—ã‚‡ã†ã€‚flywayã®å‘½åè¦å‰‡ã«å¾“ã„ã¾ã™ã€‚

- src/main/resources/db/migration/V1.0.0__init.sql

```sql
CREATE TABLE users
(
    id            BIGSERIAL PRIMARY KEY,
    username      TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL
);

CREATE TABLE tasks
(
    id           BIGSERIAL PRIMARY KEY,
    user_id      BIGINT REFERENCES users (id) ON DELETE CASCADE,
    title        TEXT    NOT NULL,
    description  TEXT    NOT NULL,
    is_completed BOOLEAN NOT NULL,
    created_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at   TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

micronaut-flywayã‚’å…¥ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚¢ãƒ—ãƒªã‚’èµ·å‹•ã™ã‚Œã°è‡ªå‹•ã§ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ°ã‚Šã¾ã™ã€‚é–‹ç™ºä¸­ã®å¤‰æ›´ã¯ã€docker compose down -vã§ãƒ‡ãƒ¼ã‚¿ã‚’ä¸¸ã”ã¨æ¶ˆã—ã¦ã—ã¾ã†ã®ãŒæ¥½ã§ã—ã‚‡ã†ã€‚

ãŸã ã—ã€ä»Šã®ã¾ã¾ã ã¨èµ·å‹•ã§ããªã„ã¨æ€ã„ã¾ã™ã€‚detasourcesã‚’å®šç¾©ã—ã¦ãã ã•ã„ã€‚ç§ã®å¥½ã¿ã§HOCONï¼ˆapplication.confï¼‰ã«æ›¸ãç›´ã—ã¦ã„ã¾ã™ã€‚

```hocon
datasources {
  default {
    db-type: postgres
    dialect: POSTGRES
    url: "jdbc:postgresql://localhost:5432/demo"
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  }
}
flyway {
  datasources.default.enabled: true
}
micronaut {
  application.name: micronaut-demo
  security {
    authentication: bearer
    token.jwt.signatures.secret.generator.secret: ${?JWT_GENERATOR_SIGNATURE_SECRET}
  }
}
```

ã§ã¯repositoryã®å®Ÿè£…ã«å…¥ã‚Šã¾ã™ã€‚

å˜ç´”ãªCRUDæ“ä½œãªã®ã§micronaut-data-jdbcã®CrudRepositoryã§æ¥½ã—ã¾ã™ã€‚ãŸã ã—ã€tableæ§‹é€ ã‚’domain layerã«å…¬é–‹ã—ãªã„ã‚ˆã†å¤‰æ›å‡¦ç†ã‚’æŒŸã¿ã¾ã™ã€‚

ãƒ¬ã‚³ãƒ¼ãƒ‰ã«å¯¾å¿œã™ã‚‹ã‚¯ãƒ©ã‚¹ã¯Entityã¨å‘½åã™ã‚‹ã“ã¨ãŒå¤šã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€DDDã®Domain Entityã¨æ··ã–ã£ã¦ã‚„ã‚„ã“ã—ã„ã®ã§Tableã¨åä»˜ã‘ã¾ã™ã€‚

```
adapter/
  persistence/
    crud/
      TaskCrudRepository.kt
    table/
      TaskTable.kt
    TaskRepositoryImpl.kt
```

```kotlin
package micronaut.demo.adapter.persistence.table

import io.micronaut.data.annotation.GeneratedValue
import io.micronaut.data.annotation.Id
import io.micronaut.data.annotation.MappedEntity
import io.micronaut.data.annotation.MappedProperty
import micronaut.demo.domain.entity.NewTask
import micronaut.demo.domain.entity.Task
import java.time.Instant

@MappedEntity("tasks")
data class TaskTable(
    @Id
    @GeneratedValue
    val id: Long?,

    @MappedProperty("user_id")
    val userId: Long,

    @MappedProperty("title")
    val title: String,

    @MappedProperty("description")
    val description: String,

    @MappedProperty("is_completed")
    val isCompleted: Boolean,

    @MappedProperty("created_at")
    val createdAt: Instant,

    @MappedProperty("updated_at")
    val updatedAt: Instant,
)

fun NewTask.toTable(): TaskTable =
    TaskTable(
        id = null,
        userId = userId,
        title = title,
        description = description,
        isCompleted = false,
        createdAt = Instant.now(),
        updatedAt = Instant.now(),
    )

fun Task.toTable(): TaskTable =
    TaskTable(
        id = id,
        userId = userId,
        title = title,
        description = description,
        isCompleted = isCompleted,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )

fun TaskTable.toTask(): Task =
    Task(
        id = id ?: throw IllegalStateException("Task Id is null. Maybe not saved yet."),
        userId = userId,
        title = title,
        description = description,
        isCompleted = isCompleted,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )
```

```kotlin
package micronaut.demo.adapter.persistence.crud

import io.micronaut.data.jdbc.annotation.JdbcRepository
import io.micronaut.data.model.query.builder.sql.Dialect
import io.micronaut.data.repository.CrudRepository
import micronaut.demo.adapter.gateway.table.TaskTable

@JdbcRepository(dialect = Dialect.POSTGRES)
interface TaskCrudRepository : CrudRepository<TaskTable, Long> {
    fun findByUserId(userId: Long): List<TaskTable>
}
```

```kotlin
package micronaut.demo.adapter.persistence

import jakarta.inject.Singleton
import micronaut.demo.adapter.gateway.crud.TaskCrudRepository
import micronaut.demo.adapter.gateway.table.toTable
import micronaut.demo.adapter.gateway.table.toTask
import micronaut.demo.domain.entity.NewTask
import micronaut.demo.domain.entity.Task
import micronaut.demo.domain.repository.TaskRepository
import kotlin.jvm.optionals.getOrNull

@Singleton
class TaskRepositoryImpl(
    private val taskCrudRepository: TaskCrudRepository,
) : TaskRepository {
    override fun save(task: NewTask): Task {
        val table = task.toTable()
        return taskCrudRepository.save(table)
            .toTask()
    }

    override fun findById(id: Long): Task? {
        return taskCrudRepository.findById(id).getOrNull()
            ?.toTask()
    }

    override fun findByUserId(userId: Long): List<Task> {
        return taskCrudRepository.findByUserId(userId)
            .map { it.toTask() }
    }

    override fun update(task: Task): Task {
        val table = task.toTable()
        return taskCrudRepository.update(table)
            .toTask()
    }

    override fun deleteById(id: Long): Boolean {
        if (!taskCrudRepository.existsById(id)) {
            return false
        }
        taskCrudRepository.deleteById(id)
        return true
    }
}
```

## èªè¨¼ï¼ˆjwtï¼‰

ä»Šå›ã¯micronaut-security-jwtã‚’ä½¿ã„ã¾ã™ã€‚

https://guides.micronaut.io/latest/micronaut-security-jwt-gradle-kotlin.html

`/login` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯è‡ªå‹•ã§ä½œæˆã•ã‚Œã‚‹ã®ã§ã€ç™»éŒ²å‡¦ç†ã¨èªè¨¼çµæœã®åˆ©ç”¨æ–¹æ³•ã‚’è¿½åŠ ã™ã‚Œã°ã„ã„ã§ã™ã€‚
`/auth/register` ã§ã¯èªè¨¼ã‚’é™¤å¤–ã™ã‚‹ã®ã‚’å¿˜ã‚Œãšã«ã€‚

```
adapter/
  controller/
    request/
      RegisterRequest.kt
    AuthController.kt
```

```kotlin
package micronaut.demo.adapter.controller

import io.micronaut.http.annotation.Body
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Post
import micronaut.demo.adapter.controller.request.RegisterRequest
import micronaut.demo.application.usecase.UserRegisterUsecase

@Controller("/auth")
class AuthController(
    private val userRegisterUsecase: UserRegisterUsecase,
) {
    @Post("/register")
    @Secured(SecurityRule.IS_ANONYMOUS)
    fun register(
        @Body body: RegisterRequest,
    ) {
        userRegisterUsecase.execute(body.name, body.password)
    }
}
```

```kotlin
package micronaut.demo.adapter.controller.request

data class RegisterRequest(
    val username: String,
    val password: String,
)
```

ã“ã“ã¾ã§ç°¡å˜ã®ãŸã‚ã«è‰²ã€…ã¨é›‘ã«æ›¸ã„ã¦ãã¾ã—ãŸãŒã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–ã¯æµçŸ³ã«ã‚„ã‚Šã¾ã™ã€‚Springã‹ã‚‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã ã‘ãŠå€Ÿã‚Šã—ã¾ã—ã‚‡ã†ã€‚

```kotlin
    implementation("org.springframework.security:spring-security-crypto:6.4.4")
    implementation("commons-logging:commons-logging:1.3.5") // ä¾å­˜
```

```
application/
  usecase/
    UserRegisterUsecase.kt
```

```kotlin
package micronaut.demo.application.usecase

import jakarta.inject.Singleton
import micronaut.demo.domain.entity.NewUser
import micronaut.demo.domain.repository.UserRepository
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder

interface UserRegisterUsecase {
    fun execute(username: String, password: String)
}

@Singleton
class UserRegisterUsecaseImpl(
    private val userRepository: UserRepository,
) : UserRegisterUsecase {
    private val encoder = BCryptPasswordEncoder()

    override fun execute(username: String, password: String) {
        if (userRepository.existsByUsername(username)) {
            throw IllegalArgumentException("User with name $name already exists")
        }
        val hash = encoder.encode(password)
        val user = NewUser(name, hash)
        userRepository.save(user)
    }
}
```

Repositoryå‘¨ã‚Šã‚‚ã¾ã¨ã‚ã¦ä½œã‚Šã¾ã™ã€‚

```
domain/
  repository/
    UserRepository.kt
adapter/
  persistence/
    crud/
      UserCrudRepository.kt
    table/
      UserTable.kt
    UserRepositoryImpl.kt
```

```kotlin
package micronaut.demo.domain.repository

import micronaut.demo.domain.entity.NewUser
import micronaut.demo.domain.entity.User

interface UserRepository {
    fun save(user: NewUser): User
    fun findByUsername(username: String): User?
    fun existsByUsername(username: String): Boolean
}
```

```kotlin
package micronaut.demo.adapter.persistence

import jakarta.inject.Singleton
import micronaut.demo.adapter.persistence.crud.UserCrudRepository
import micronaut.demo.adapter.persistence.table.toTable
import micronaut.demo.adapter.persistence.table.toUser
import micronaut.demo.domain.entity.NewUser
import micronaut.demo.domain.entity.User
import micronaut.demo.domain.repository.UserRepository

@Singleton
class UserRepositoryImpl(
    private val userCrudRepository: UserCrudRepository,
) : UserRepository {
    override fun save(user: NewUser): User {
        val table = user.toTable()
        return userCrudRepository.save(table)
            .toUser()
    }

    override fun findByUsername(username: String): User? {
        return userCrudRepository.findByUsername(username)
            ?.toUser()
    }

    override fun existsByUsername(username: String): Boolean {
        return userCrudRepository.existsByUsername(username)
    }
}
```

```kotlin
package micronaut.demo.adapter.persistence.crud

import io.micronaut.data.jdbc.annotation.JdbcRepository
import io.micronaut.data.model.query.builder.sql.Dialect
import io.micronaut.data.repository.CrudRepository
import micronaut.demo.adapter.gateway.table.UserTable

@JdbcRepository(dialect = Dialect.POSTGRES)
interface UserCrudRepository : CrudRepository<UserTable, Long> {
    fun findByName(name: String): UserTable?
    fun existsByName(name: String): Boolean
}
```

```kotlin
package micronaut.demo.adapter.persistence.table

import io.micronaut.data.annotation.GeneratedValue
import io.micronaut.data.annotation.Id
import io.micronaut.data.annotation.MappedEntity
import io.micronaut.data.annotation.MappedProperty
import micronaut.demo.domain.entity.NewUser
import micronaut.demo.domain.entity.User

@MappedEntity("users")
data class UserTable(
    @Id
    @GeneratedValue
    val id: Long?,

    @MappedProperty("username")
    val username: String,

    @MappedProperty("password_hash")
    val passwordHash: String,
)

fun NewUser.toTable(): UserTable =
    UserTable(
        id = null,
        username = username,
        passwordHash = passwordHash,
    )

fun UserTable.toUser(): User =
    User(
        id = id ?: throw IllegalStateException("User Id is null. Maybe not saved yet."),
        username = username,
        passwordHash = passwordHash,
    )
```

ã‚ã¨ã¯èªè¨¼ãƒ—ãƒ­ãƒã‚¤ãƒ€ã‚’ä½œã‚Šã¾ã™ã€‚

```
adapter/
  security/
    AuthenticationProviderUserPassword.kt
```

```kotlin
package micronaut.demo.adapter.security

import io.micronaut.http.HttpRequest
import io.micronaut.security.authentication.AuthenticationFailed
import io.micronaut.security.authentication.AuthenticationRequest
import io.micronaut.security.authentication.AuthenticationResponse
import io.micronaut.security.authentication.provider.HttpRequestAuthenticationProvider
import jakarta.inject.Singleton
import micronaut.demo.domain.repository.UserRepository
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder

@Singleton
class AuthenticationProviderUserPassword<B>(
    private val userRepository: UserRepository,
) : HttpRequestAuthenticationProvider<B> {
    private val passwordEncoder = BCryptPasswordEncoder()

    override fun authenticate(
        requestContext: HttpRequest<B>?,
        authRequest: AuthenticationRequest<String, String>
    ): AuthenticationResponse {
        val username = authRequest.identity
        val password = authRequest.secret

        val user = userRepository.findByUsername(username)
        if (user != null && passwordEncoder.matches(password, user.passwordHash)) {
            return AuthenticationResponse.success(username, listOf("ROLE_USER"), mapOf("userId" to user.id))
        } else {
            return AuthenticationFailed()
        }
    }
}
```

ã“ã‚Œã§ `Authentication.attributes` ã‹ã‚‰ userId ã‚’å–ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

### Adapter (Controller) å®Œæˆ

ã§ã¯ `/tasks` ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã—ã¾ã—ã‚‡ã†ã€‚

```
adapter/
  controller/
    TaskController.kt
```

```kotlin
package micronaut.demo.adapter.controller

import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Body
import io.micronaut.http.annotation.Consumes
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Delete
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Patch
import io.micronaut.http.annotation.PathVariable
import io.micronaut.http.annotation.Post
import io.micronaut.http.annotation.Produces
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.rules.SecurityRule
import micronaut.demo.adapter.controller.request.CreateTaskRequest
import micronaut.demo.adapter.controller.request.UpdateTaskRequest
import micronaut.demo.adapter.controller.response.TaskResponse
import micronaut.demo.adapter.controller.response.toResponse
import micronaut.demo.application.usecase.CreateTaskUsecase
import micronaut.demo.application.usecase.DeleteTaskUsecase
import micronaut.demo.application.usecase.ListTaskUsecase
import micronaut.demo.application.usecase.UpdateTaskUsecase

@Controller("/tasks")
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Secured(SecurityRule.IS_AUTHENTICATED)
class TaskController(
    private val createTaskUsecase: CreateTaskUsecase,
    private val listTaskUsecase: ListTaskUsecase,
    private val updateTaskUsecase: UpdateTaskUsecase,
    private val deleteTaskUsecase: DeleteTaskUsecase,
) {
    @Post
    fun createTask(
        authentication: Authentication,
        @Body body: CreateTaskRequest,
    ): TaskResponse {
        val userId = extractUserId(authentication)
        val task = createTaskUsecase.execute(userId, body.title, body.description)
        return task.toResponse()
    }

    @Get
    fun listTasks(
        authentication: Authentication,
    ): List<TaskResponse> {
        val userId = extractUserId(authentication)
        return listTaskUsecase.execute(userId)
            .map { it.toResponse() }
    }

    @Patch("/{id}")
    @Consumes(MediaType.APPLICATION_JSON_MERGE_PATCH)
    fun updateTask(
        authentication: Authentication,
        @PathVariable id: Long,
        @Body body: UpdateTaskRequest,
    ): TaskResponse {
        val userId = extractUserId(authentication)
        val task = updateTaskUsecase.execute(userId, id, body.title, body.description, body.isCompleted)
        return task.toResponse()
    }

    @Delete("/{id}")
    fun deleteTask(
        authentication: Authentication,
        @PathVariable id: Long,
    ) {
        val userId = extractUserId(authentication)
        deleteTaskUsecase.execute(userId, id)
    }

    private fun extractUserId(authentication: Authentication): Long {
        return authentication.attributes["userId"] as? Long
            ?: throw IllegalArgumentException("User ID not found in authentication attributes")
    }
}
```

## å®Œæˆ

ã“ã‚Œã§ä¸€é€šã‚Šã®å®Ÿè£…ãŒã§ãã¾ã—ãŸã€‚
`/auth/register` ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ç™»éŒ²ã—ã¦ã€ `/login` ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—ã—ã€ `/tasks` ã§CRUDæ“ä½œãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ãƒ†ã‚¹ãƒˆã¯å¾Œæ—¥è¶³ã™ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

# ã¾ã¨ã‚

Kotlin + Micronaut ã®æ§‹æˆã§ã€ã‚·ãƒ³ãƒ—ãƒ«ãªTODOã‚¢ãƒ—ãƒªã‚’ä½œæˆã—ã¾ã—ãŸã€‚
Micronaut ã¯è»½é‡ã§é«˜æ€§èƒ½ãªãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã‚ã‚Šã€Kotlin ã‹ã‚‰ã‚‚ç°¡å˜ã«ä½¿ãˆã¾ã™ã€‚ãœã²ãŠè©¦ã—ã¦ã‚ã‚Œã€‚

# ãŠã¾ã‘

å€‹äººçš„ã«ãƒãƒã£ãŸç‚¹ãƒ¡ãƒ¢

## @QueryValueã‚’10å€‹ä»¥ä¸Šä»˜ã‘ã‚‰ã‚Œãªã„

ãƒã‚°ãªã®ã‹ä»•æ§˜ãªã®ã‹å¾®å¦™ãªãƒ©ã‚¤ãƒ³ãªã®ã§ã™ãŒã€@QueryValueã‚’10å€‹ä»¥ä¸Šä»˜ã‘ã‚‹ã¨ã¬ã‚‹ã½ã‚’åãã¾ã™ã€‚
@RequestBeanã‚’ä½¿ã£ã¦ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚Œã°å›é¿ã§ãã¾ã™ã€‚

ãŸã ã—ã€@RequestBeanã®å¯¾è±¡ã¯Javaã®POJOã‚’æœŸå¾…ã™ã‚‹ã®ã§ã€KSPã®åˆ¶ç´„ã§constructorå¼•æ•°ã«ã§ãã¾ã›ã‚“ã€‚
å„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯varã§å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```kotlin
@Controller("/foo")
class FooController {
    @Get
    fun get(
        @RequestBean fooRequest: FooRequest,
    ): FooResponse {
        TODO()
    }
}

@Introspected
class FooRequest {
    @QueryValue("foo")
    var foo: String? = null
    @QueryValue("bar")
    var bar: String? = null
    @QueryValue("baz")
    var baz: String? = null
    // ...
}
```

## Flywayã®gradle pluginãŒå‹•ã‹ãªã„

Micronautã¯å…¨ãé–¢ä¿‚ãªã„ã‚“ã§ã™ãŒã€flywayã®gradle pluginå‹•ã„ãŸã“ã¨ãªã„ã§ã™ã€‚
æ¯å›è‡ªåˆ†ã§gradle taskã‚’ä½œã£ã¦ã¾ã™ã€‚

build.gradle.ktsã§æœ€æ–°ç‰ˆå‹•ã‹ã›ã‚‹æ›¸ãæ–¹ã”å­˜ã˜ã®æ–¹æ•™ãˆã¦ãã ã•ã„ã€‚ã€‚ã€‚
