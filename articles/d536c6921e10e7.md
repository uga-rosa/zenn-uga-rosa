---
title: "è‡ªå‹•è£œå®Œã€IME ã§ Deno KV ã‚’ä½¿ã†"
emoji: "ğŸˆ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Vim", "Neovim", "Deno"]
published: true
---

# ã¯ã˜ã‚ã«

æœ€è¿‘ Open Beta ã«ãªã£ãŸ Deno KV (SQLite ãƒ™ãƒ¼ã‚¹ã®ã‚­ãƒ¼ãƒãƒªãƒ¥ãƒ¼ã‚¹ãƒˆã‚¢) ã‚’ä½¿ã£ã¦ã¿ã¾ã—ãŸã€‚
å®Ÿéš›ã«ä½¿ã£ã¦æ„Ÿã˜ãŸæ„Ÿæƒ³ã‚’ã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã® TIPS ã®ã‚ˆã†ãªå½¢ã§çºã‚ã¾ã™ã€‚
ç¶²ç¾…çš„ãªèª¬æ˜ã‚’ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

Deno KV ã¯ã¾ã å®‰å®šåŒ–ã—ã¦ã„ãªã„ã®ã§ã€ã“ã®è¨˜äº‹ã®å†…å®¹ã‚’å‚è€ƒã«ã™ã‚‹ã¨ãã¯æ›´æ–°æ—¥æ™‚ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
åˆ©ç”¨ã™ã‚‹ã«ã¯ `--unstable-kv` ãƒ•ãƒ©ã‚°ãŒå¿…è¦ã§ã™ã€‚

:::message
Deno 1.39.2 ã®é ƒã«åŸ·ç­†ã•ã‚Œã¾ã—ãŸã€‚
:::

https://github.com/uga-rosa/ddc-source-dictionary
https://github.com/vim-skk/skkeleton

ãƒãƒ‹ãƒ¥ã‚¢ãƒ«

https://docs.deno.com/kv/manual

# ç›®çš„

ddc-source-dictionary ã¯å˜èªãŒç¾…åˆ—ã•ã‚ŒãŸè¾æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€è‡ªå‹•è£œå®Œã®å€™è£œã¨ã—ã¦æä¾›ã—ã¾ã™ã€‚
skkeleton ã¯ SKK è¾æ›¸ã‚’èª­ã¿è¾¼ã¿ã€æ¼¢å­—ã¸ã®å¤‰æ›ã§ç”¨ã„ã¾ã™ã€‚

ã©ã¡ã‚‰ã‚‚èµ·å‹•æ™‚ã®ãƒ•ã‚¡ã‚¤ãƒ« I/O ãŒãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã¨ãªã‚‹ã®ã§ã€æ”¹å–„ã§ããªã„ã ã‚ã†ã‹ã¨ä»¥å‰ã‚ˆã‚Šè€ƒãˆã¦ã„ã¾ã—ãŸã€‚
ãã“ã§ã“ã® Deno KV ã‚’ä½¿ã£ã¦ä¸€åº¦è¾æ›¸ã®ä¸­èº«ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åŒ–ã™ã‚Œã°ã€ãã‚Œä»¥é™ã®èµ·å‹•ãŒé«˜é€ŸåŒ–ã•ã‚Œã‚‹ã ã‚ã†ã¨æ€ã„å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚

ã—ã‹ã—ã€å…¥åŠ›ã«ä¸€è‡´ã™ã‚‹å€™è£œã®åé›†ã¯éå¸¸ã«é »ç¹ã«è¡Œã‚ã‚Œã‚‹æ“ä½œã§ã‚ã‚Šã€ã“ã®é€Ÿåº¦ã«ã‚ˆã£ã¦ã¯å®Ÿç”¨çš„ã¨ã¯è¨€ãˆã¾ã›ã‚“ã€‚
ç‰¹ã« ddc-source-dictionary ã®å…ƒã€…ã®å®Ÿè£…ã§ã¯ãƒ¡ãƒ¢ãƒªä¸Šã§ Trie æœ¨ã‚’æ§‹ç¯‰ã—ã¦ãŠã‚Šã€å€™è£œã®çµã‚Šè¾¼ã¿ã¯éå¸¸ã«é«˜é€Ÿã§ã™ã€‚
ãã®æ¯”è¼ƒçµæœã‚‚ã¾ã¨ã‚ã¦å ±å‘Šã—ã¾ã™ã€‚

[cmp-dictionary](https://github.com/uga-rosa/cmp-dictionary) ã§ SQLite ã‚’ä½¿ã£ãŸã¨ãã«ã€å€™è£œã®åé›†ãŒé…ãã‚ã¾ã‚Šæ¨å¥¨ã§ãã‚‹å‡ºæ¥ã«ãªã‚‰ãªã‹ã£ãŸè‹¦ã„æ€ã„å‡ºã€‚ã€‚

# ä½¿ã„æ–¹

ä»Šå›ã®ç›®çš„ã‹ã‚‰ã€æ®ç™ºã™ã‚‹ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãªæ–¹æ³•ã¯æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚
SQLite ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ç”¨ã„ã¾ã™ã€‚
`Deno.openKv()` ã®å¼•æ•°ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä¿å­˜ã™ã‚‹ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¾ã—ã‚‡ã†ã€‚

```typescript
const database = await Deno.openKv("/path/to/database")
```

Deno KV ã¯ã‚­ãƒ¼ãƒãƒªãƒ¥ãƒ¼ã‚¹ãƒˆã‚¢ã§ã™ã€‚æœ€ã‚‚åŸºæœ¬çš„ãªæ“ä½œã¯ `set` ã¨ `get` ã§ã—ã‚‡ã†ã€‚

- å¯¾å¿œã™ã‚‹ Key ã¨ Value ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ ([kv.set()](https://deno.land/api@v1.39.2?s=Deno.Kv&unstable=&p=prototype.set))
- Key ã‚’ä½¿ã£ã¦å¯¾å¿œã™ã‚‹ Value ã‚’å–å¾—ã™ã‚‹ ([kv.get()](https://deno.land/api@v1.39.2?s=Deno.Kv&unstable=&p=prototype.get))

```typescript
await database.set(["ab", "c"], "def")
console.log((await database.get(["ab", "c"])).value) // -> "def"
```

ä»Šå›ã®ã‚ˆã†ãªã€ã‚ã‚‹æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹å€™è£œã‚’å…¨ã¦å–å¾—ã™ã‚‹æ“ä½œã‚’è¡Œã†ãŸã‚ã«ã¯ [kv.list()](https://deno.land/api@v1.39.2?s=Deno.Kv&unstable=&p=prototype.list) ãŒä¾¿åˆ©ã§ã™ã€‚
ãŸã ã—ã€ãã®ãŸã‚ã«ã¯ã‚­ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«å°‘ã—å·¥å¤«ãŒè¦ã‚Šã¾ã™ã€‚

## ã‚­ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ 

Deno KV ã®ã‚­ãƒ¼ã®å‹ã¯[ã“ã®ã‚ˆã†ã«](https://deno.land/api@v1.39.2?s=Deno.KvKey&unstable=)ãªã£ã¦ã„ã¾ã™ã€‚
[Deno.KvKeyPart](https://deno.land/api@v1.39.2?s=Deno.KvKeyPart&unstable=) ã®é…åˆ—ã¨ã‚ã‚Šã¾ã™ãŒã€ã“ã‚Œã¯ `Uint8Array | string | number | bigint | boolean | symbol` ã§ã™ã€‚

ä»Šå›ã¯ `string[]` ã¨ã—ã¦æ‰±ã„ã¾ã™ã€‚

ã“ã®ã‚­ãƒ¼ã§ã™ãŒã€çµã‚Šè¾¼ã¿ã«ã¯ã‚­ãƒ¼ã—ã‹ä½¿ãˆãªã„ã®ã§ã“ã¡ã‚‰ã«ã‚ã‚‹ç¨‹åº¦æƒ…å ±ã‚’ç››ã‚Šè¾¼ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
å…·ä½“çš„ã«ã¯

- 1ã¤ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã§è¤‡æ•°ã®è¾æ›¸ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€è¾æ›¸ã®ãƒ‘ã‚¹ã‚’å…¥ã‚Œã‚‹
  - SQL ã¨é•ã„ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“
  - ãã®ãŸã‚ã‚­ãƒ¼ã‚’éšå±¤åŒ–ã™ã‚‹ã“ã¨ã§ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²ã—ã¾ã™
- è¾æ›¸ã®æ›´æ–°ã‚’æ¤œçŸ¥ã™ã‚‹ãŸã‚ã« `mtime` ã‚’è¨˜éŒ²ã™ã‚‹
  - `[path, "mtime"]` ã‚’ã‚­ãƒ¼ã«ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒæœ€æ–°ã®è¾æ›¸ã«å¯¾å¿œã—ãŸã‚‚ã®ã‹ã©ã†ã‹åˆ¤æ–­ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸ
- çµã‚Šè¾¼ã¿ã«ä½¿ã†æ–‡å­—åˆ—ã‚’åˆ†å‰²ã™ã‚‹
  - å®Ÿéš›ã®å˜èªã®ã‚­ãƒ¼ã¯ `[path, "word", ...word]` ã®ã‚ˆã†ãªæ§‹é€ ã«ã—ã¾ã™
  - ä¾‹ãˆã° ddc-source-dictionary ã§ `Vim` ã¨ã„ã†å˜èªã‚’ç™»éŒ²ã™ã‚‹ã«ã¯ã€`await database.set(["/path/to/dict", "word", "V", "i", "m"], "Vim")` ã¨ã—ã¾ã™ã€‚
  - ã“ã‚Œã¯ [kv.list()](https://deno.land/api@v1.39.2?s=Deno.Kv&unstable=&p=prototype.list) ã®åˆ¶ç´„ã§ã€`prefix` ã¯é…åˆ—ã¨ã—ã¦ã®å‰æ–¹ä¸€è‡´ã—ã‹è¦‹ã¦ãã‚Œãªã„ãŸã‚ã§ã™ï¼ˆ`{ prefix: ["word", "a"] }` ã§ã¯ `["word", "ab"]` ãŒè¦‹ã¤ã‹ã‚‰ãªã„ï¼‰ã€‚

ã‚ãŸã‚Šã§ã—ã‚‡ã†ã‹ã€‚

## ãƒ‡ãƒ¼ã‚¿ã®ç™»éŒ²

å½“ç„¶ã§ã™ãŒã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«å€¤ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã®ã‚‚ãƒ•ã‚¡ã‚¤ãƒ« I/O ã§ã™ã€‚
æ„šç›´ã«ã‚„ã‚‹ã¨åˆæœŸåŒ–ã«è«å¤§ãªæ™‚é–“ãŒã‹ã‹ã£ãŸã®ã§ã€[Deno.AtomicOperation](https://deno.land/api@v1.39.2?s=Deno.AtomicOperation&unstable=) ã‚’ä½¿ã£ã¦å·¥å¤«ã—ã¾ã—ãŸã€‚
ãŒã€ã“ã®ã‚ãŸã‚Šã‚’åŠ¹ç‡çš„ã«ã‚„ã‚‹ã«ã¯ã¾ã æ‰‹æ³•ãŒæ•´å‚™ã•ã‚Œã¦ã„ãªã„ãªã¨ã„ã†æ„Ÿæƒ³ã§ã™ï¼ˆãƒ™ãƒ¼ã‚¿ç‰ˆãªã®ã§ä»•æ–¹ãªã„ï¼‰ã€‚

ä»Šå› AtomicOperation ã‚’ä½¿ã†ç›®çš„ã¯ I/O ã‚’æ¸›ã‚‰ã™ã“ã¨ã§ã™ã€‚
ã¤ã¾ã‚Š [commit()](https://deno.land/api@v1.39.2?s=Deno.AtomicOperation&unstable=&p=prototype.commit) ã®é »åº¦ã‚’æœ€å°åŒ–ã—ãŸã„ã‚ã‘ã§ã™ã€‚

ã—ã‹ã— AtomicOperation ã§ `set()` ã‚’ã¾ã¨ã‚ã‚‹ã«ã¯2ã¤ã®åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚
1ã¤ç›®ã¯ mutations ã®å›æ•°ã§ã™ã€‚

:::details ã‚³ãƒ¼ãƒ‰ã¨ã‚¨ãƒ©ãƒ¼
```typescript :database.ts
const database = await Deno.openKv();
let atm = database.atomic();
for (let i = 0; i < 1001; i++) {
  atm = atm.set(["a"], "a");
}
await atm.commit();
```

```bash
$ deno run -A --unstable-kv ./database.ts
error: Uncaught (in promise) TypeError: too many mutations (max 1000)
await atm.commit();
          ^
    at doAtomicWriteInPlace (ext:deno_kv/01_db.ts:626:16)
    at AtomicOperation.commit (ext:deno_kv/01_db.ts:401:32)
    at file:///home/uga/dotfiles/nvim/database.ts:6:11
    at eventLoopTick (ext:core/01_core.js:182:7)
```
:::

ã“ã‚Œã¯å˜ç´”ã§ã€æ“ä½œãŒ 1000 å›ã‚’è¶Šãˆã‚‹ã¨å¼•ã£æ›ã‹ã‚Šã¾ã™ã€‚

ã‚‚ã†1ã¤ãŒå„ä»‹ã§ã€Total key size ã®åˆ¶é™ã§ã™ã€‚

:::details ã‚³ãƒ¼ãƒ‰ã¨ã‚¨ãƒ©ãƒ¼
```typescript :database.ts
const database = await Deno.openKv();
let atm = database.atomic();
for (let i = 0; i < 500; i++) {
  atm = atm.set(Array(100).fill("a"), "a");
}
await atm.commit();
```

```bash
$ deno run -A --unstable-kv ./database.ts
error: Uncaught (in promise) TypeError: total key size too large (max 81920 bytes)
await atm.commit();
          ^
    at doAtomicWriteInPlace (ext:deno_kv/01_db.ts:626:16)
    at AtomicOperation.commit (ext:deno_kv/01_db.ts:401:32)
    at file:///home/uga/dotfiles/nvim/database.ts:6:11
    at eventLoopTick (ext:core/01_core.js:182:7)
```
:::

ä»Šåº¦ã¯500å›ã—ã‹æ“ä½œã—ã¦ã„ãªã„ã®ã«ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã—ãŸã€‚
total key size ãŒ 81920 bytes ã‚’è¶ŠãˆãŸã‹ã‚‰ã¨ã‚ã‚Šã¾ã™ã­ã€‚
ã“ã‚Œã¯ `set()` ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã®ã‚µã‚¤ã‚ºã®åˆè¨ˆå€¤ã‹ã‚‰ç”Ÿã˜ã‚‹åˆ¶é™ãªã®ã§ã™ãŒã€ã“ã®ã€Œã‚­ãƒ¼ã®ã‚µã‚¤ã‚ºã€ãŒæ›²è€…ã§ã™ã€‚

key ã¯ TypeScript ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã¯ `Deno.KvKey` ã§ã™ãŒã€Rust ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ `u8` ã®ãƒã‚¤ãƒˆåˆ—ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚
ã“ã®éš›ã€è¦ç´ ã”ã¨ã«å…ƒã®å‹ã‚’ç‰¹å®šã™ã‚‹ãŸã‚ã®è­˜åˆ¥å­ã‚„ã€é…åˆ—ã®è¦ç´ ã‚’åŒºåˆ‡ã‚‹ãŸã‚ã®ãƒã‚¤ãƒˆãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚

ä»Šå›ã¯ string ã—ã‹ä½¿ã‚ãªã„ã®ã§ã“ã‚Œã«çµã‚Šã¾ã™ãŒã€

1. é…åˆ—ã®å„è¦ç´ ã«å¯¾ã—ã¦æ–‡å­—åˆ—ã§ã‚ã‚‹ã“ã¨ã®è­˜åˆ¥å­ `0x02` ã‹ã‚‰é–‹å§‹
2. å„è¦ç´ ã®æ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒˆåˆ—ã«å¤‰æ›ã—ã€`0x00` ã‚’ `0xFF` ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
3. æœ«å°¾ã« `0x00` ã‚’è¿½åŠ 

ã¨ãªã‚‹ã®ã§ã€`['a', 'bc']` ã¯ `0x02` `0x61` `0x00` `0x02` `0x62` `0x63` `0x00` ã®7ãƒã‚¤ãƒˆã«ãªã‚Šã¾ã™ã€‚

ã§ã™ã®ã§ã€ã‚­ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—ã™ã‚‹ã«ã¯æ¬¡ã®ã‚ˆã†ãªé–¢æ•°ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

```typescript
const Encoder = new TextEncoder();
function calcKeySize(key: string[]): number {
  let size = 0;
  for (const k of key) {
    const encoded = Encoder.encode(k);
    size += encoded.reduce((acc, cur) => acc + (cur === 0x00 ? 2 : 1), 2);
  }
  return size;
}
```

ä»¥ä¸Šã‚ˆã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ« I/O ã‚’æœ€å°åŒ–ã™ã‚‹ãŸã‚ã«ã¯ã€æ“ä½œãŒ 1000 å›ã‚’è¶Šãˆã‚‹ã‹ total key size ãŒ 81920 bytes ã‚’è¶Šãˆã‚‹ã‹ã®ã©ã¡ã‚‰ã‹ã‚’æº€ãŸã—ãŸã‚‰ `commit()` ã™ã‚‹ã€ã¨ã„ã†åˆ¤å®šã‚’ä»•è¾¼ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚

https://github.com/uga-rosa/ddc-source-dictionary/blob/main/denops/%40ddc-sources/lib/kv.ts

ã¡ãªã¿ã«ã€ä¸Šè¨˜ã® `kv.list()` ã§ prefix ãŒéƒ¨åˆ†ä¸€è‡´ã‚’è¦‹ã¤ã‘ã¦ãã‚Œãªã„ç†ç”±ã¯æã‚‰ãã“ã‚Œã ã¨æ€ã„ã¾ã™ã€‚
`["ab"]` ã¯ `0x02` `0x61` `0x62` `0x00` ã§ã‚ã‚Š `["a"]` ã¯ `0x02` `0x61` `0x00` ã§ã™ã‹ã‚‰ã€ç¢ºã‹ã«å‰æ–¹ä¸€è‡´ã—ã¦ã¾ã›ã‚“ã­ã€‚

## å€™è£œã®æ¤œç´¢

ç¾åœ¨æœ‰åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹è¾æ›¸ã”ã¨ã«ã€prefix ã«å‰æ–¹ä¸€è‡´ã™ã‚‹å€™è£œã‚’åé›†ã—ã¾ã™ã€‚
ã“ã“ã‚‚ç´ ç›´ã«ã‚„ã‚‹ã¨ä¸Šæ‰‹ãã„ã‹ãªã„ç‚¹ãŒã‚ã‚Šã¾ã—ãŸã€‚

```typescript
export class Dictionary {
  #db: Deno.Kv
  #activePath: string[]

  // ...

  async search(
    prefix: string,
  ): Promise<Item[]> {
    const items: Item[] = [];
    for (const [path, active] of this.#activePath) {
      if (!active) {
        continue;
      }
      for await (
        const entry of this.#db.list<string>({
          prefix: [path, "word", ...prefix],
          start: [path, "word", ...prefix],
        })
      ) {
        items.push({ word: entry.value });
      }
    }
    return items;
  }
}
```

`prefix` ã¨ `start` ã«åŒã˜ã‚‚ã®ã‚’æŒ‡å®šã—ã¦ã„ã¾ã™ã­ã€‚
ã“ã‚Œã¯ `prefix` ã ã‘ã ã¨å®Œå…¨ä¸€è‡´ã™ã‚‹å€™è£œãŒå–ã‚Œãªã„ã®ã«ã€`start` ã‚’å…¥ã‚Œã‚‹ã¨å–ã‚Œã‚‹ã‚ˆã†ã«ãªã‚‹ã‹ã‚‰ã§ã™ã€‚
çµæ§‹æ€ªã—ã„æŒ™å‹•ãªã®ã§ issue ã¨ã—ã¦å ±å‘Šæ¸ˆã¿ã§ã™ãŒã€åå¿œãŒãªã„ã®ã§ãƒã‚°ã‹ä»•æ§˜ã‹ã¯åˆ†ã‹ã‚Šã¾ã›ã‚“ã€‚

:::details ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
```typescript :test.ts
const data = [
  { key: ["data"], value: 0 },
  { key: ["data", 1], value: 1 },
];

const db = await Deno.openKv("./test.sqlite3");
for (const d of data) {
  await db.set(d.key, d.value);
}

console.log("only prefix");
for await (const entry of db.list({ prefix: ["data"] })) {
  console.log(entry.value);
}

console.log("prefix and start");
for await (const entry of db.list({ prefix: ["data"], start: ["data"] })) {
  console.log(entry.value);
}

db.close();
```

```bash :result
$ deno run -A --unstable-kv ./test.ts
only prefix
1
prefix and start
0
1
```
:::

# é€Ÿåº¦æ¯”è¼ƒ

çµæœã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚
10ä¸‡ä»¶ã»ã©ã®å€™è£œã‹ã‚‰æ¢ç´¢ã—ã€10 ms ã‚¹ã‚±ãƒ¼ãƒ«ã§åé›†ã§ãã‚‹ã®ã¯ååˆ†ãªé€Ÿåº¦ã§ã¯ãªã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ

:::details ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
```typescript
import { TextLineStream } from "https://deno.land/std@0.208.0/streams/mod.ts";

const path = "/usr/share/dict/words";
const database = await Deno.openKv("./database");
let atm = database.atomic();

const Encoder = new TextEncoder();
function calcKeySize(keys: string[]): number {
  let size = 0;
  for (const key of keys) {
    const encoded = Encoder.encode(key);
    size += encoded.reduce((acc, cur) => acc + (cur === 0x00 ? 2 : 1), 2);
  }
  return size;
}

let mutationCount = 0;
let totalKeySize = 0;
async function setAtom(key: string[], value: string) {
  const keySize = calcKeySize(key);
  if (mutationCount >= 1000 || totalKeySize + keySize > 81920) {
    await atm.commit();
    atm = database.atomic();
    mutationCount = 0;
    totalKeySize = 0;
  }
  atm = atm.set(key, value);
  mutationCount++;
  totalKeySize += keySize;
}

// Initialize database
let time = performance.now();

const stat = Deno.statSync(path);
const mtime = stat.mtime?.getTime();
if (!mtime || (await database.get([path, "mtime"])).value !== mtime) {
  const lineStream = Deno.openSync(path).readable
    .pipeThrough(new TextDecoderStream())
    .pipeThrough(new TextLineStream());
  for await (const line of lineStream) {
    for (const word of line.split(/\s+/)) {
      if (word !== "") {
        await setAtom([path, "word", ...word], word);
      }
    }
  }
  await atm.commit();
  await database.set([path, "mtime"], mtime);
}

console.log(`Initialize: ${performance.now() - time} ms`);

// Search words by prefix
const prefixes = "abcdefghijklmnopqrstuvwxyz".split("");

for (const prefix of prefixes) {
  time = performance.now();

  const items = [];
  for await (
    const entry of database.list<string>({
      prefix: [path, "word", prefix],
      start: [path, "word", prefix],
    })
  ) {
    items.push({ word: entry.value });
  }

  console.log(
    `Search by prefix '${prefix}': Number of words is ${items.length}: Time is ${
      performance.now() - time
    } ms`,
  );
}
```
:::

```
Initialize: 1841.1240440000001 ms
Search by prefix 'a': Number of words is 4705: Time is 25.88997500000005 ms
Search by prefix 'b': Number of words is 4913: Time is 27.485771999999997 ms
Search by prefix 'c': Number of words is 8260: Time is 45.36883399999988 ms
Search by prefix 'd': Number of words is 5176: Time is 27.3865330000001 ms
Search by prefix 'e': Number of words is 3307: Time is 18.01066199999991 ms
Search by prefix 'f': Number of words is 3745: Time is 18.53727099999992 ms
Search by prefix 'g': Number of words is 2799: Time is 14.104373999999552 ms
Search by prefix 'h': Number of words is 3122: Time is 15.26544100000001 ms
Search by prefix 'i': Number of words is 3385: Time is 17.978665999999976 ms
Search by prefix 'j': Number of words is 777: Time is 3.8198680000000422 ms
Search by prefix 'k': Number of words is 621: Time is 3.063626000000113 ms
Search by prefix 'l': Number of words is 2644: Time is 12.752908999999818 ms
Search by prefix 'm': Number of words is 4496: Time is 22.978982000000087 ms
Search by prefix 'n': Number of words is 1560: Time is 7.876393999999891 ms
Search by prefix 'o': Number of words is 1967: Time is 10.591051999999763 ms
Search by prefix 'p': Number of words is 6822: Time is 34.23828300000014 ms
Search by prefix 'q': Number of words is 417: Time is 2.143696000000091 ms
Search by prefix 'r': Number of words is 4721: Time is 23.46596099999988 ms
Search by prefix 's': Number of words is 10070: Time is 52.34290299999975 ms
Search by prefix 't': Number of words is 4354: Time is 22.268744999999853 ms
Search by prefix 'u': Number of words is 1826: Time is 9.000050999999985 ms
Search by prefix 'v': Number of words is 1280: Time is 6.1433320000001 ms
Search by prefix 'w': Number of words is 2362: Time is 12.512147999999797 ms
Search by prefix 'x': Number of words is 57: Time is 0.5083490000001802 ms
Search by prefix 'y': Number of words is 285: Time is 1.6422410000000127 ms
Search by prefix 'z': Number of words is 151: Time is 0.8030710000002728 ms
```

Trie æœ¨ã®æ–¹ãŒ 1 æ¡ä»¥ä¸Šæ—©ã„ã§ã™ãŒã€Deno KV ã‚‚ååˆ†å®Ÿç”¨çš„ãªé€Ÿåº¦ã§ã™ã­ã€‚

:::details ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
```typescript
import { TextLineStream } from "https://deno.land/std@0.208.0/streams/mod.ts";

const path = "/usr/share/dict/words";

class TrieNode {
  readonly children: Record<string, TrieNode>;
  endOfWord: boolean;

  constructor() {
    this.children = {};
    this.endOfWord = false;
  }
}

class Trie {
  readonly root: TrieNode;

  constructor() {
    this.root = new TrieNode();
  }

  insert(word: string): void {
    let current = this.root;
    for (let i = 0; i < word.length; i++) {
      const ch = word.charAt(i);
      const node = current.children[ch] ?? new TrieNode();
      current.children[ch] = node;
      current = node;
    }
    current.endOfWord = true;
  }

  private searchPrefix(
    node: TrieNode,
    prefix: string,
    wordList: string[],
  ): void {
    if (node.endOfWord) {
      wordList.push(prefix);
    }
    for (const ch in node.children) {
      this.searchPrefix(node.children[ch], prefix + ch, wordList);
    }
  }

  search(prefix: string): string[] {
    let node = this.root;
    for (let i = 0; i < prefix.length; i++) {
      node = node.children[prefix.charAt(i)];
      if (node === undefined) {
        return [];
      }
    }
    const wordList: string[] = [];
    this.searchPrefix(node, prefix, wordList);
    return wordList;
  }
}

// Initialize database
let time = performance.now();

const trie = new Trie();
const lineStream = Deno.openSync(path).readable
  .pipeThrough(new TextDecoderStream())
  .pipeThrough(new TextLineStream());
for await (const line of lineStream) {
  for (const word of line.split(/\s+/)) {
    if (word !== "") {
      trie.insert(word);
    }
  }
}

console.log(`Initialize: ${performance.now() - time} ms`);

// Search words by prefix
const prefixes = "abcdefghijklmnopqrstuvwxyz".split("");

for (const prefix of prefixes) {
  time = performance.now();

  const items = trie.search(prefix).map((word) => ({ word }));

  console.log(
    `Search by prefix '${prefix}': Number of words is ${items.length}: Time is ${
      performance.now() - time
    } ms`,
  );
}
```
:::

```
Initialize: 185.635855 ms
Search by prefix 'a': Number of words is 4705: Time is 1.5532199999999818 ms
Search by prefix 'b': Number of words is 4913: Time is 1.2792749999999842 ms
Search by prefix 'c': Number of words is 8260: Time is 1.5127829999999847 ms
Search by prefix 'd': Number of words is 5176: Time is 0.7586410000000114 ms
Search by prefix 'e': Number of words is 3307: Time is 0.48531500000001415 ms
Search by prefix 'f': Number of words is 3745: Time is 0.5526940000000025 ms
Search by prefix 'g': Number of words is 2799: Time is 0.4029250000000104 ms
Search by prefix 'h': Number of words is 3122: Time is 0.48266499999999724 ms
Search by prefix 'i': Number of words is 3385: Time is 0.5046949999999981 ms
Search by prefix 'j': Number of words is 777: Time is 0.11220900000000711 ms
Search by prefix 'k': Number of words is 621: Time is 0.09358899999998016 ms
Search by prefix 'l': Number of words is 2644: Time is 0.36822599999999284 ms
Search by prefix 'm': Number of words is 4496: Time is 0.7106530000000078 ms
Search by prefix 'n': Number of words is 1560: Time is 0.33206599999999753 ms
Search by prefix 'o': Number of words is 1967: Time is 0.32374599999999987 ms
Search by prefix 'p': Number of words is 6822: Time is 0.9599990000000105 ms
Search by prefix 'q': Number of words is 417: Time is 0.07502900000000068 ms
Search by prefix 'r': Number of words is 4721: Time is 0.7690519999999879 ms
Search by prefix 's': Number of words is 10070: Time is 1.6252819999999986 ms
Search by prefix 't': Number of words is 4354: Time is 0.850560999999999 ms
Search by prefix 'u': Number of words is 1826: Time is 0.48629499999998416 ms
Search by prefix 'v': Number of words is 1280: Time is 0.24391699999998195 ms
Search by prefix 'w': Number of words is 2362: Time is 0.40450500000000034 ms
Search by prefix 'x': Number of words is 57: Time is 0.016899999999992588 ms
Search by prefix 'y': Number of words is 285: Time is 0.059868999999991956 ms
Search by prefix 'z': Number of words is 151: Time is 0.03650000000001796 ms
```

# çµ‚ã‚ã‚Šã«

ã¾ã ãƒ™ãƒ¼ã‚¿ç‰ˆãªã®ã§å¾®å¦™ãªã¨ã“ã‚ã‚‚ã‚ã‚Šã¾ã™ãŒã€ã‹ãªã‚Šè‰¯ã•ãã†ãªé›°å›²æ°—ã¯æ„Ÿã˜ã¦ã„ã¾ã™ã€‚
ä»Šå¾Œã®é–‹ç™ºã‚’å¿œæ´ã—ã¦ã„ã¾ã™ã€‚
