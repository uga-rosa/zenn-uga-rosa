---
title: "SKKå®Ÿè£…å…¥é–€ (2) ã²ã‚‰ãŒãªå…¥åŠ›"
emoji: "ğŸ–Šï¸"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Neovim", "Lua", "ime", "skk"]
published: true
---

[ç¬¬ä¸€å› ãƒ­ãƒ¼ãƒå­— -> ã²ã‚‰ãŒãªå¤‰æ›](https://zenn.dev/uga_rosa/articles/ec5281d5a95a57)
å‰å› åŒä¸Š
æ¬¡å› ã¾ã 

# 0. ã¯ã˜ã‚ã«

ã“ã®è¨˜äº‹ã¯ç¬¬äºŒå›ã§ã™ã€‚å‰å›ã¾ã§ã®å†…å®¹ã‚’å‰æã¨ã—ã¾ã™ã€‚

ã•ã¦å‰å›ã¯ã€ãƒ­ãƒ¼ãƒå­—ã®å…¥åŠ›ã‚’ 1 æ–‡å­—ãšã¤å—ã‘å–ã‚Šã²ã‚‰ãŒãªã«å¤‰æ›ã™ã‚‹ä»•çµ„ã¿ã‚’ä½œã‚Šã¾ã—ãŸã€‚
ä»Šå›ã¯ Neovim ä¸Šã§å®Ÿéš›ã«ã²ã‚‰ãŒãªã‚’å…¥åŠ›ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

ã“ã®è¨˜äº‹æ™‚ç‚¹ã§ã®é€²æ—ã‚³ãƒŸãƒƒãƒˆã¯ã“ã¡ã‚‰ã€‚
https://github.com/uga-rosa/skk-learning.nvim/tree/0f462f87d516d4e40f64ed37c8c69edad31021c7

# 1. å¿…è¦ãªæ©Ÿèƒ½

ä»Šå›å®Ÿè£…ã™ã‚‹æ©Ÿèƒ½ã¯å¤§ããä»¥ä¸‹ã® 2 ã¤ã«åˆ†ã‘ã‚‰ã‚Œã¾ã™ã€‚

1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’å¥ªã„å‰å›ã® `kanaInput()` é–¢æ•°ã«é€ã‚‹
2. ç¾åœ¨ã®å…¥åŠ›çŠ¶æ…‹ã‚’ãƒãƒƒãƒ•ã‚¡ã«åæ˜ ã™ã‚‹

## 1.1. å…¥åŠ›ã®å¥ªå–

Neovim ã«ãŠã„ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’ç›£è¦–ã™ã‚‹æ–¹æ³•ã¯ã„ãã¤ã‹ã‚ã‚Šã¾ã™ã€‚
(Thanks [@kuu](https://zenn.dev/kuu)!)

1. å…¨éƒ¨ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ (imap/lmap)
2. `InsertCharPre` ã‚¤ãƒ™ãƒ³ãƒˆã§ `v:char` ã‚’ä½¿ã†
3. `vim.on_key()` ã‚’ä½¿ã†

ä»Šå›ã¯ 1. ã‚’æ¡ç”¨ã—ã¾ã™ã€‚

### 1.1.1. ãƒãƒƒãƒ”ãƒ³ã‚°

ä¸€ç•ªã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚
ãŸã ã—ã€imap ã‚’ä½¿ã†ã¨æ—¢å­˜ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ç ´å£Šã™ã‚‹ãƒªã‚¹ã‚¯ãŒã‚ã‚Šã¾ã™ã€‚
- buffer-local ã¯ global ãªãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ç ´å£Šã—ã¾ã›ã‚“ãŒã€æ—¢ã« buffer-local ãªãƒãƒƒãƒ”ãƒ³ã‚°ãŒã‚ã‚Œã°ä¸Šæ›¸ãã—ã¦ã—ã¾ã„ã¾ã™
  - [é€€é¿ã•ã›ã‚‹](https://github.com/uga-rosa/jam.nvim/blob/main/lua/jam/keymap.lua)ã“ã¨ã‚‚å‡ºæ¥ã¾ã™ãŒã€`lmap` ã‚’ä½¿ã†æ–¹ãŒç´ ç›´ã§ã—ã‚‡ã†
- å°‘ã—è¤‡é›‘ã§ã™ã®ã§å®Ÿéš›ã®ä½¿ã„æ–¹ã¯å¾Œè¿°ã—ã¾ã™

:::details :h language-mapping
```
						*language-mapping*
":lmap" defines a mapping that applies to:
- Insert mode
- Command-line mode
- when entering a search pattern
- the argument of the commands that accept a text character, such as "r" and
  "f"
- for the input() line
Generally: Whenever a character is to be typed that is part of the text in the
buffer, not a Vim command character.  "Lang-Arg" isn't really another mode,
it's just used here for this situation.
   The simplest way to load a set of related language mappings is by using the
'keymap' option.  See |45.5|.
   In Insert mode and in Command-line mode the mappings can be disabled with
the CTRL-^ command |i_CTRL-^| |c_CTRL-^|. These commands change the value of
the 'iminsert' option.  When starting to enter a normal command line (not a
search pattern) the mappings are disabled until a CTRL-^ is typed.  The state
last used is remembered for Insert mode and Search patterns separately.  The
state for Insert mode is also used when typing a character as an argument to
command like "f" or "t".
   Language mappings will never be applied to already mapped characters.  They
are only used for typed characters.  This assumes that the language mapping
was already done when typing the mapping. Correspondingly, language mappings
are applied when recording macros, rather than when applying them.
```
:::

### 1.1.2. InsertCharPre

Insert ãƒ¢ãƒ¼ãƒ‰ã§æ–‡å­—ãŒå…¥åŠ›ã•ã‚ŒãŸã¨ãã€ãã®æ–‡å­—ãŒå®Ÿéš›ã«æŒ¿å…¥ã•ã‚Œã‚‹å‰ã«ç™ºç«ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã§ã™ã€‚
å…¥åŠ›ã•ã‚ŒãŸæ–‡å­—ã¯ `v:char` ã«æ ¼ç´ã•ã‚Œã¦ãŠã‚Šã€ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆä¸­ã«å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ä»Šå›ã®ç”¨é€”ã«ã¯å¹¾ã¤ã‹ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚
- `<BS>` ã§ç™ºç«ã—ãªã„
- `v:char` ã«ç‰¹æ®Šæ–‡å­—ãŒæŒ‡å®šã§ããªã„ï¼ˆliterally ã«æ‰±ã‚ã‚Œã‚‹ã€‚`<BS>` ãŒ `<`, `B`, `S`, `>` ã®4æ–‡å­—ã«ãªã£ã¦ã—ã¾ã†ï¼‰
  > When |v:char| is set to more than one character this text is inserted literally.
- Insert ãƒ¢ãƒ¼ãƒ‰é™å®šã®ãŸã‚ã€CommandLine ãƒ¢ãƒ¼ãƒ‰ã¸ã®æ‹¡å¼µãŒã§ããªã„

:::details :h InsertCharPre
```
							*InsertCharPre*
InsertCharPre			When a character is typed in Insert mode,
				before inserting the char.
				The |v:char| variable indicates the char typed
				and can be changed during the event to insert
				a different character.  When |v:char| is set
				to more than one character this text is
				inserted literally.

				Cannot change the text. |textlock|
```
:::

### 1.1.3. vim.on_key()

namespace ã«ç´ä»˜ã‘ã‚ã‚‰ã‚†ã‚‹ã‚­ãƒ¼å…¥åŠ›ã‚’å‚å—ã—ã¾ã™ã€‚
åˆ¶å¾¡ãŒå›°é›£ã§ã™ã€‚

- `nvim_buf_clear_namespace()` ã§ã‚¯ãƒªã‚¢ã§ããªã„
- mapping ã‚’è©•ä¾¡ã—ãŸã‚ã¨ã®ã‚­ãƒ¼ãŒé€ä¿¡ã•ã‚Œã‚‹

:::details :h vim.on_key()
```
on_key({fn}, {ns_id})                                           *vim.on_key()*
    Adds Lua function {fn} with namespace id {ns_id} as a listener to every,
    yes every, input key.

    The Nvim command-line option |-w| is related but does not support
    callbacks and cannot be toggled dynamically.

    Note:
        {fn} will not be cleared by |nvim_buf_clear_namespace()|

    Note:
        {fn} will receive the keys after mappings have been evaluated

    Parameters: ~
      â€¢ {fn}     (function) Callback function. It should take one string
                 argument. On each key press, Nvim passes the key char to
                 fn(). |i_CTRL-V| If {fn} is nil, it removes the callback for
                 the associated {ns_id}
      â€¢ {ns_id}  integer? Namespace ID. If nil or 0, generates and returns a
                 new |nvim_create_namespace()| id.

    Return: ~
        (integer) Namespace id associated with {fn}. Or count of all callbacks
        if on_key() is called without arguments.

    Note:
        {fn} will be removed if an error occurs while calling.
```
:::

## 1.2. å…¥åŠ›çŠ¶æ…‹ã‚’ãƒãƒƒãƒ•ã‚¡ã¸åæ˜ ã™ã‚‹

æ–°ã—ã„å¤‰æ›çµæœã‚’å…¥åŠ›ã™ã‚‹ã ã‘ã§ã¯è¶³ã‚Šãšã€å‰å›ã¾ã§ã®å…¥åŠ›ã¨ã®å·®åˆ†ã‚’å‰Šé™¤ã™ã‚‹ãªã©ã®æ“ä½œãŒå¿…è¦ã§ã™ã€‚
å…·ä½“ä¾‹ã‚’æŒ™ã’ã¾ã™ã€‚`zenn` ã¨å…¥åŠ›ã™ã‚‹ã¨ãã€ãƒãƒƒãƒ•ã‚¡ã¯
```
z
ãœ
ãœn
ãœã‚“
```
ã¨å¤‰ã‚ã£ã¦ã„ãã¯ãšã§ã™ã€‚

`e` ã‚’å…¥åŠ›ã—ãŸã¨ãã€Neovim ã«ã¯ `\bãœ` ãŒé€ä¿¡ã•ã‚Œã¦ã»ã—ã„ã®ã§ã™ï¼ˆ`\b` ã¯ `<BS>` ã§ã™ï¼‰ã€‚

æ–°ã—ã„å…¥åŠ›ã«ã‚ˆã‚‹å¤‰æ›´ã«å¿œã˜ã¦ã€ä¸€è‡´ã—ãªã„éƒ¨åˆ†ã‚’å‰Šé™¤ã—ã€æ–°ã—ã„å…¥åŠ›ã‚’è¿½åŠ ã™ã‚‹å‘½ä»¤ã‚’ä½œæˆã™ã‚‹ãŸã‚ã« `PreEdit` ã‚¯ãƒ©ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

# 2. å®Ÿè£…

# 2.1. PreEdit

é †ç•ªãŒå‰å¾Œã—ã¾ã™ãŒã€ã¾ãšã¯ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹å¯¾è±¡ã®æ©Ÿèƒ½ã‚’ä½œã‚ã†ã¨ã„ã†ã“ã¨ã§ `PreEdit` ã‚¯ãƒ©ã‚¹ã‹ã‚‰ã«ã—ã¾ã—ã‚‡ã†ã€‚

```lua:preedit.lua
local utf8 = require("skk.utf8")

---ãƒãƒƒãƒ•ã‚¡ã®å¤‰åŒ–ã‹ã‚‰å·®åˆ†ã‚’ç”Ÿæˆã™ã‚‹
---@class PreEdit
---@field current string
---@field kakutei string
local PreEdit = {}

---@return PreEdit
function PreEdit.new()
  return setmetatable({
    current = "",
    kakutei = "",
  }, { __index = PreEdit })
end

---@param str string
function PreEdit:doKakutei(str)
  self.kakutei = self.kakutei .. str
end

---@param next string
---@return string
function PreEdit:output(next)
  local ret
  if self.kakutei == "" and vim.startswith(next, self.current) then
    ret = next:sub(#self.current)
  else
    local current_len = utf8.len(self.current) --[[@as integer]]
    ret = string.rep("\b", current_len) .. self.kakutei .. next
  end
  self.current = next
  self.kakutei = ""
  return ret
end

return PreEdit
```

`utf8` ã¯ Lua 5.3 ä»¥é™ã«å­˜åœ¨ã™ã‚‹[çµ„ã¿è¾¼ã¿ãƒ©ã‚¤ãƒ–ãƒ©ãƒª](https://www.lua.org/manual/5.3/manual.html#6.5)ã‚’æ¨¡å€£ã—ã¦ç§ãŒä½œã£ãŸã‚‚ã®ã§ã™ã€‚
ãƒ•ã‚¡ã‚¤ãƒ« 1 ã¤ãªã®ã§çµ„ã¿è¾¼ã¿ã‚„ã™ãä¾¿åˆ©ã§ã™ã€‚
https://github.com/uga-rosa/utf8.nvim
Lua ã® `#` ã§æ±‚ã¾ã‚‹æ–‡å­—åˆ—é•·ã¯ãƒã‚¤ãƒˆé•·ãªã®ã§ã€å¿…è¦ãª `<BS>` æ•°ã¨ä¸€è‡´ã—ã¾ã›ã‚“ã€‚
ãªã®ã§æ–‡å­—æ•°ã‚’æ±‚ã‚ã‚‹ãŸã‚ã« `utf8.len()` ã‚’ä½¿ã„ã¾ã™ã€‚

ã“ã‚“ãªæ„Ÿã˜ã«å‹•ãã¾ã™ã€‚
SKK ã«ãŠã‘ã‚‹ã²ã‚‰ãŒãªã®ç›´æ¥å…¥åŠ›ã‚’ã‚¨ãƒŸãƒ¥ã£ã¦ã„ã¾ã™ã€‚
`output()` ã«ã¯ Context ã‹ã‚‰ç¾åœ¨ã®å…¥åŠ›çŠ¶æ…‹ãŒæ¸¡ã•ã‚Œã¾ã™ã€‚
å¤‰æ›ãŒç¢ºå®šã—ãŸã¨ãã¯ `doKakutei()` ã§ `kakutei` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ç©ã¿ã¾ã™ï¼ˆ`output()`ãŒå‘¼ã°ã‚Œã‚‹ã¾ã§ä¿æŒã•ã‚Œã¾ã™ï¼‰ã€‚

```lua:preedit_spec.lua
local PreEdit = require("skk.preedit")

describe("preedit test", function()
  it("normal", function()
    local preEdit = PreEdit.new()
    -- input 'ã²ã‚‰'
    assert.equals("h", preEdit:output("h"))
    preEdit:doKakutei("ã²")
    assert.equals("\bã²", preEdit:output(""))
    assert.equals("r", preEdit:output("r"))
    preEdit:doKakutei("ã‚‰")
    assert.equals("\bã‚‰", preEdit:output(""))
  end)

  it("emoji", function()
    local preEdit = PreEdit.new()
    assert.equals("ğŸ’©", preEdit:output("ğŸ’©"))
    assert.equals("\bğŸš½", preEdit:output("ğŸš½"))
    assert.equals("\bğŸ¦", preEdit:output("ğŸ¦"))
  end)
end)
```

`PreEdit` ã¯ `Context` ã§ç®¡ç†ã—ã¾ã™ã®ã§ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è¿½åŠ ã—ã¾ã™ã€‚

## 2.2. å®Ÿéš›ã®å…¥åŠ›çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ InputState

ä»Šã¯ã¾ã ã„ã„ã§ã™ãŒã€ä»Šå¾Œå¤‰æ›ã‚’å®Ÿè£…ã™ã‚‹ä¸Šã§å…¨ã¦ã‚’ `Context` ã«ä»»ã›ã¦ãŠãã®ã¯è¤‡é›‘ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚
ãã“ã§å®Ÿéš›ã®å…¥åŠ›çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ `InputState` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
  - **å®Ÿéš›ã®** ã¨ä»˜ã‘ãŸã®ã¯ã€å·®åˆ†ã ã‘ã‚’ç®¡ç†ã™ã‚‹ `PreEdit` ã¨ã®å¯¾æ¯”ã§ã™ã€‚

`Context` ã® `feed` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åˆ†é›¢ã—ã¾ã™ã€‚
  - `fixed` ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å‰Šé™¤ã—ã¾ã™ã€‚
    - SKK ã§ã¯äº‹å‰ã«å¤‰æ›é–‹å§‹ã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ã€å³åº§ã«ç¢ºå®šã•ã‚Œã¾ã™ã€‚
    - å‰å›ç”¨æ„ã—ãŸã®ã¯ãƒ†ã‚¹ãƒˆã®ãŸã‚ã®ä»®ãƒãƒƒãƒ•ã‚¡ã¨ã—ã¦ä½¿ã†ãŸã‚ã§ã™ã€‚

```lua:state.lua
---@alias State InputState

---@alias InputMode "direct"

---@class InputState
---@field type "input"
---@field mode InputMode
---@field feed string
local InputState = {}

function InputState.new()
  return setmetatable({
    type = "input",
    mode = "direct",
    feed = "",
  }, { __index = InputState })
end

---@return string
function InputState:toString()
  return self.feed
end

return {
  InputState = InputState,
}
```

## 2.3. Context ã‚’ä¿®æ­£

ã“ã“ã¾ã§ã®å¤‰æ›´ã‚’ `Context` ã«å…¥ã‚Œã‚‹ã¨ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
`toString()` ãƒ¡ã‚½ãƒƒãƒ‰ã¯ `state` ãŒæŒã£ã¦ã„ã‚‹çŠ¶æ…‹ã‚’æ•´å½¢ã—ã¦å‡ºåŠ›ã™ã‚‹ã‚‚ã®ã§ã€çµæœã¯ `preEdit:output()` ãªã©ã«æ¸¡ã•ã‚Œã¾ã™ã€‚

```lua:context.lua
local KanaTable = require("skk.kana.kana_table")
local PreEdit = require("skk.preedit")
local InputState = require("skk.state").InputState

---@class Context
---@field kanaTable KanaTable å…¨ã¦ã®å¤‰æ›ãƒ«ãƒ¼ãƒ«
---@field preEdit PreEdit
---@field state State
---@field tmpResult? KanaRule feedã«å®Œå…¨ä¸€è‡´ã™ã‚‹å¤‰æ›ãƒ«ãƒ¼ãƒ«
local Context = {}

function Context.new()
  local self = setmetatable({}, { __index = Context })
  self.kanaTable = KanaTable.new()
  self.preEdit = PreEdit.new()
  self.state = InputState.new()
  return self
end

---@param candidates? KanaRule[]
function Context:updateTmpResult(candidates)
  candidates = candidates or self.kanaTable:filter(self.state.feed)
  self.tmpResult = nil
  for _, candidate in ipairs(candidates) do
    if candidate.input == self.state.feed then
      self.tmpResult = candidate
      break
    end
  end
end

---@return string
function Context:toString()
  return self.state:toString()
end

return Context
```

## 2.4. kanaInput() ã‚’ä¿®æ­£

ã“ã“ã¾ã§ã®å¤‰æ›´ã‚’ `input.lua` ã® `kanaInput()` ã«é©å¿œã—ã¾ã™ã€‚

```lua:input.lua
local Input = {}

---@param context Context
---@param result KanaRule
local function acceptResult(context, result)
  local preEdit = context.preEdit
  local state = context.state
  local kana, feed = result.output, result.next

  preEdit:doKakutei(kana)
  state.feed = feed
end

---@param context Context
---@param char string
function Input.kanaInput(context, char)
  local state = context.state
  local input = state.feed .. char
  local candidates = context.kanaTable:filter(input)
  if #candidates == 1 and candidates[1].input == input then
    -- å€™è£œãŒä¸€ã¤ã‹ã¤å®Œå…¨ä¸€è‡´ã€‚ç¢ºå®š
    acceptResult(context, candidates[1])
    context:updateTmpResult()
  elseif #candidates > 0 then
    -- æœªç¢ºå®š
    state.feed = input
    context:updateTmpResult(candidates)
  elseif context.tmpResult then
    -- æ–°ã—ã„å…¥åŠ›ã«ã‚ˆã‚ŠtmpResultã§ç¢ºå®š
    acceptResult(context, context.tmpResult)
    context:updateTmpResult()
    Input.kanaInput(context, char)
  else
    -- å…¥åŠ›ãƒŸã‚¹ã€‚context.tmpResultã¯æ—¢ã«nil
    state.feed = ""
    Input.kanaInput(context, char)
  end
end

return Input
```

ãƒ†ã‚¹ãƒˆã¯ã“ã®ã‚ˆã†ã«ä¿®æ­£ã•ã‚Œã¾ã™ã€‚
`dispatch()` ã¯å…¥åŠ›ã‚’æ¨¡å€£ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ä»Šå¾Œã‚’è¦‹è¶Šã—ã¦åˆ†é›¢ã—ã¾ã—ãŸã€‚
å®Ÿéš›ã¯ä¸€æ–‡å­—ã”ã¨ã« `preEdit:output(context:toString())` ãŒç™ºè¡Œã•ã‚Œã€Neovim ã®ãƒãƒƒãƒ•ã‚¡ã«å¤‰æ›´ãŒåæ˜ ã•ã‚Œã¾ã™ã€‚

```lua:input_spec.lua
local Context = require("skk.context")
local dispatch = require("skk.testutil").dispatch

---@type Context
local context

---@param input string
---@param expect string
local function test(input, expect)
  dispatch(context, input)
  assert.are.equals(expect, context.preEdit:output(""))
end

describe("Tests for input.lua", function()
  before_each(function()
    context = Context.new()
  end)

  it("single char", function()
    test("ka", "ã‹")
  end)

  it("multiple chars (don't use tmpResult)", function()
    test("ohayou", "ãŠã¯ã‚ˆã†")
  end)

  it("multiple chars (use tmpResult)", function()
    test("amenbo", "ã‚ã‚ã‚“ã¼")
  end)

  it("multiple chars (use tmpResult and its next)", function()
    test("uwwwa", "ã†wã£ã‚")
  end)

  it("mistaken input", function()
    test("rkakyra", "ã‹ã‚‰")
  end)
end)
```

```lua:testutil.lua
local input = require("skk.input")

local M = {}

---@param context Context
---@param keys string
function M.dispatch(context, keys)
  for key in vim.gsplit(keys, "") do
    input.kanaInput(context, key)
  end
end

return M
```

## 2.5. ã‚­ãƒ¼å…¥åŠ›å…¨èˆ¬ã‚’ç®¡ç†ã™ã‚‹ handleKey()

`context` ã®ä¿æŒã‚„ä»Šå¾Œ SKK ã®å„ç¨®æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã¦ã„ãã“ã¨ã‚’è€ƒãˆã‚‹ã¨ã€`kanaInput()` ã‚’ç›´æ¥ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã®ã¯ã‚ã¾ã‚Šè‰¯ã„é¸æŠã¨ã¯è¨€ãˆãªã„ã§ã—ã‚‡ã†ã€‚
ãã“ã§ `handle()` ã¨ `handleKey()` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
`handle()` ã¯ `init.lua` ã‹ã‚‰å…¬é–‹ã™ã‚‹ãŸã‚ã®é–¢æ•°ã§ã€å®Ÿéš›ã®åˆ†å²å‡¦ç†ã¯ `keymap.lua` ã® `handleKey()` ã«ç§»è­²ã—ã¾ã™ã€‚

```lua:init.lua
local Context = require("skk.context")
local Keymap = require("skk.keymap")

local context = Context.new()

local M = {}

---@param key string
---@return string
function M.handle(key)
  Keymap.handleKey(context, key)
  local output = context.preEdit:output(context:toString())
  return output
end

return M
```

```lua:keymap.lua
local Input = require("skk.input")

local Keymap = {}

local keyMaps = {
  input = setmetatable({}, {
    __index = function()
      return Input.kanaInput
    end,
  }),
}

---@param context Context
---@param key string
function Keymap.handleKey(context, key)
  keyMaps[context.state.type][key](context, key)
end

return Keymap
```

`KeyMaps` ãŒå°‘ã—å†—é•·ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€`henkanState` ã‚‚ãã®ã†ã¡å®Ÿè£…ã™ã‚‹ã®ã§ã“ã†ã—ã¦ãŠãã¾ã™ã€‚

ã‚ã¨ã¯ `handle()` ã‚’ `expr` ã§ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚Œã°å‹•ãã¯ãšã§ã™ã€‚
ã¨ã„ã†ã“ã¨ã§ `lmap` ã®è©±ã‚’ã—ã¾ã—ã‚‡ã†ã€‚

## 2.6. language-mapping

`language-mapping` ã¯ã€ãŸã  `:lmap` ã§ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚
ä¸€ã¤ä»¥ä¸Šã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å®šç¾©ã—ãŸçŠ¶æ…‹ã§ã€`<C-^>` ã‚’é€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```
						*i_CTRL-^*
CTRL-^		Toggle the use of typing language characters.
		When language |:lmap| mappings are defined:
		- If 'iminsert' is 1 (langmap mappings used) it becomes 0 (no
		  langmap mappings used).
		- If 'iminsert' has another value it becomes 1, thus langmap
		  mappings are enabled.
		When no language mappings are defined:
		- If 'iminsert' is 2 (Input Method used) it becomes 0 (no
		  Input Method used).
		- If 'iminsert' has another value it becomes 2, thus the Input
		  Method is enabled.
		When set to 1, the value of the "b:keymap_name" variable, the
		'keymap' option or "<lang>" appears in the status line.
		The language mappings are normally used to type characters
		that are different from what the keyboard produces.  The
		'keymap' option can be used to install a whole number of them.
```

ã¨ã„ã†è¨³ã§ã€SKK ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹ãŸã‚ã® `enable()` (`toggle()`) ã¨ã€ãã‚Œã‚’å‘¼ã³å‡ºã™ Neovim å´ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ã¨ã‚Šã‚ãˆãšã²ã‚‰ãŒãªã®å…¥åŠ›ãŒå‡ºæ¥ã‚Œã°ã„ã„ã®ã§ã€å°æ–‡å­—ã® `a-z` ã‚’å¥ªã†ã‚ˆã†ã«ã—ã¦ã¿ã¾ã—ãŸã€‚

```lua:init.lua
local Context = require("skk.context")
local Keymap = require("skk.keymap")

local context = Context.new()

local M = {}

---@param key string
---@return string
function M.handle(key)
  Keymap.handleKey(context, key)
  local output = context.preEdit:output(context:toString())
  return output
end

local keys = vim.split("abcdefghijklmnopqrstuvwxyz", "")

---@return string
function M.enable()
  if vim.bo.iminsert ~= 1 then
    for _, lhs in ipairs(keys) do
      vim.keymap.set("l", lhs, function()
        return M.handle(lhs)
      end, { buffer = true, silent = true, expr = true })
    end
    return "<C-^>"
  else
    return ""
  end
end

---@return string
function M.disable()
  if vim.bo.iminsert == 1 then
    for _, lhs in ipairs(keys) do
      vim.keymap.del("l", lhs, { buffer = true })
    end
    return "<C-^>"
  else
    return ""
  end
end

---@return string
function M.toggle()
  if vim.bo.iminsert == 1 then
    return M.disable()
  else
    return M.enable()
  end
end

return M
```

```lua:plugin/skk-learning.lua
if vim.g.loaded_skk_learning then
  return
end
vim.g.loaded_skk_learning = true

vim.keymap.set("i", "<C-j>", require("skk").toggle, { expr = true })
```

ã“ã‚Œã§ã€ã‚¤ãƒ³ã‚µãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚Š `<C-j>` ã‚’ã‚¿ã‚¤ãƒ—ã™ã‚Œã°æœ‰åŠ¹åŒ–ã•ã‚Œã¾ã™ã€‚`toggle()` ãªã®ã§ã€ç„¡åŠ¹åŒ–ã—ãŸã„ã¨ãã‚‚åŒæ§˜ã§ã™ã€‚
`hiragana` ã¨å…¥åŠ›ã—ãŸã‚‰ `ã²ã‚‰ãŒãª` ã¨ã¡ã‚ƒã‚“ã¨å‡ºåŠ›ã•ã‚Œã¾ã—ãŸï¼æˆåŠŸã§ã™ï¼

![](https://storage.googleapis.com/zenn-user-upload/d33736451b5d-20230522.gif)

# 3. ãŠã‚ã‚Š

ä»Šå›ã¯ã“ã“ã¾ã§ã§çµ‚äº†ã¨ã—ã¾ã™ã€‚
ç„¡äº‹ã²ã‚‰ãŒãªã®å…¥åŠ›ãŒå‡ºæ¥ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼

æ¬¡å›ã¯ SKK è¾æ›¸ã®æ–‡æ³•ã«ã¤ã„ã¦èª¿ã¹ã€èª­ã¿è¾¼ã‚“ã§ã¿ã¾ã™ã€‚å¤‰æ›ã®å‰æº–å‚™ã§ã™ã­ã€‚
